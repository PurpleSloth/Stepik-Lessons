# -*- coding: utf-8 -*-
"""
Напишите программу, которая решает систему линейных алгебраических уравнений
методом Гаусса.

Формат входных данных:

В первой строке задаются два числа: количество уравнений nn (n \ge 1n≥1) и
количество неизвестных mm (m \ge 1m≥1). Далее идут n строк, каждая из которых
содержит m+1 число. Первые m чисел — это коэффициенты i-го уравнения системы,
а последнее, (m+1)-е число — коэффициент b_ib
i
​
 , стоящий в правой части i-го уравнения.
Формат выходных данных:
В первой строке следует вывести слово YES, если решение существует и
единственно, слово NO в случае, если решение не существует, и слово INF в
случае, когда решений существует бесконечно много. Если решение существует и
единственно, то во второй строке следует вывести решение системы в виде m
чисел, разделенных пробелом.

используем следствие из теоремы Кронекера-Капелли (https://math1.ru/education/sys_lin_eq/kapelli.html):

     а) если ранги не равны =>  решений нет

     б) если ранги равны, но меньше числа переменных =>  решений бесконечное кол-во

     в) если ранги равны и равны числу переменных => решение единственное
"""
import numpy as np

dim = input().split() # разбираем первую пару чисел - количество уравнений и неизвестных
section = int(dim[1]) # это количество неизвестных
matrix = [] # это список хранящий матрицу системы
full_matrix = [] # это список хранящий расширенную матрицу
right_part = [] # это вектор правых частей

# заполняем данными наши матрицы
for i in range(int(dim[0])):
    line = input().split()
    matrix += [line[:section]]
    full_matrix += [line]
    right_part += line[-1:]

a = np.array(matrix, dtype='float') # переводим в формат numpy матрицу системы
full_a = np.array(full_matrix, dtype='float') # переводим в формат numpy расширенную матрицу
b = np.array(right_part, dtype='float') # переводим в формат numpy вектор правых частей
matrank = int(np.linalg.matrix_rank(a)) # находим ранг матрицы
full_matrank = int(np.linalg.matrix_rank(full_a)) # находим ранг расширенной матрицы

if matrank != full_matrank:
    print('NO') # система не имеет решений
elif matrank == full_matrank and matrank < section:
    print('INF') # количество решений бесконечно
elif matrank == full_matrank and matrank == section:
    print('YES') # решение есть и оно единственное
    inv_matrix = np.linalg.inv(a) # исходя из общей формулы A*x = b, ищем обратную матрицу
    x = np.dot(inv_matrix, b) # и умножаем ее на вектор правых частей x = A(-1)* b
    print(*x)



